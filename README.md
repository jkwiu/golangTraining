# golangTraining

golang 복습(https://www.youtube.com/channel/UCZp_ftx6UB_32VfVmlS3o_A)

----------------------------------------------

<hr>

1. 트랜지스터
   1. 컴퓨터의 기본 요소
   2. CPU는 트랜지스터의 덩어리
   3. 기능
      1. 스위치(전기적 신호)
      2. 증폭
   4. 1bit = 트랜지스터 1
2. 논리소자
   1. 다음 연산을 트랜지스터를 만들 수 있다 = ``논리소자(가산기)`` = ``계산기``를 만들 수 있다는 의미
      1. AND
      2. OR
      3. XOR
         1. 0 1 ``1``
         2. 1 0 ``1``
         3. 0 0 ``0``
         4. 1 1 ``0``
      4. NOT
         1. 0 ``1``
         2. 1 ``0``
3. 컴퓨터
   1. 모래 -> 규소 -> 실리콘 -> 컴퓨터
   2. 튜링 테스트(튜링기계)
   3. 폰 노이만(우주 최강의 두뇌ㅋㅋ) 기계
      1. 메모리를 따로 쓰자(현대 컴퓨터)
4. 컴퓨터의 원리
   1. 컴퓨터는 명령을 순서대로 수행
   2. ``1``과 ``0``으로 이미지, 문자 등 모두 표현할 수 있다.
   3. ASCII CODE
      1. 255개 문자를 표현(256 = 0 ~ 255)
      2. 한 문자당 1byte
   4. UNICODE
      2. UTF-8(영문자/숫자: 1byte, 이외의 문자: 3byte)
      3. UTF-16(한 문자당 2byte)
   5. HDD -> CACHE -> CPU -> REGISTER(연산)
5. 프로그래밍 언어
   1. 프로그램
      1. 명령과 순서를 쓴 문서(글)
      2. 사람의 언어 -(코딩)-> 프로그래밍 언어 -(컴파일)-> 기계어
   2. 고급언어(디컴파일이 어렵다)
      1. 컴파일 언어
         1. 코딩 -> 빌드 -> 기계어
         2. C, C++
      2. 동적 언어(인터프리트 언어)
         1. 코딩 -> 빌드 -> 중간상태 -(프로그램이 동작할 때)-> 기계어
         2. JAVA, C#, PYTHON, JAVASCRIPT
   3. 어셈블리어(디컴파일이 쉽다)
   4. **프로그래머는 한가지 언어에 집착하면 안된다.**
6. 컴파일언어와 동적언어의 차이
   1. 컴파일언어
      1. 속도 빠름
      2. platform 별로 변환해야 함
   2. 동적언어
      1. 속도 느림
      2. platform 별로 변환필요 없음
7. Golang
   1. 2009년 google이 만듬
   2. system programing을 하기 위해 만듬
   3. 아버지
      1. 켄 톰슨(70세 현역)
         1. B언어의 아버지
      2. 롭 파이크
         1. UTF-8의 아부지
8. Hello World
   1. C#과 가깝다
   2. **공부를 하는 것은 페인트 칠하는 것과 비슷하다**
   3. package main
      1. 묶음
         1. 라이브러리
            1. 기능을 묶어놓은 것
         2. 모듈
            1. 기능을 묶어놓은 것(좀 더 포커싱)
         3. 패키지
            1. 기능을 묶어놓은 것
         4. 프레임 웍
            1. 기능을 묶어놓은 것(절차까지 포함)
         5. 엔진
            1. 기능과 다른 프로그램 툴까지 모두 묶어놓은 것
      2. package로 선언
      3. main
         1. 프로그램의 시작점
   4. func
      1. 함수
9. Go의 변수
   1.  속성
       1.  이름
       2.  값
       3.  TYPE
           1.  int
               1.  int32(4byte): -21억 ~ 21억
                   1. uint32: 42억
               2.  int64(8byte): 크다~~
                   1.  uint64: 크다~~
               3.  int8(1byte): -128 ~ 127
                   1.  uint8: 0 ~ 255
               4.  int16(2byte): 2에 16제곱 - 1(65535)
                   1.  uint16: 0 ~ 65535
           2.  float
               1.  숫자부와 지수부
               2.  float32
                   1.  숫자부는 7개까지 표현
               3.  float64
                   1.  15개까지
           3.  string
               1.  문자의 길이에 따라 다름
               2.  한 글자: rune: 1 ~ 3byte
           4.  bool
       4.  메모리 주소
           1.  어디서?
       5.  사이즈
           1.  어디까지 읽어올 것인가?
   2.  선언
10. Go의 변수2
11. Go의 연산자
    1.  연산자의 종류
        1.  이항 연산자
        2.  단항 연산자
    2.  Go의 연산자
        1.  산술 연산자
        2.  비트 연산자
            1.  4 & 2 = 0
            2.  3 & 2 = 2
            3.  4 | 2 = 6
        3.  논리 연산자
        4.  그 외
            1.  shift 연산자(``>>``, ``<<``)
            2.  clear 연산자
12. 조건연산자와 조건문
13. Switch-case와 반복문
    1.  tour.golang.org/welcome/1
14. For 문 예제
    1.  ch14 코드 참고
15. 함수
    1.  기능의 모듈화
    2.  참조호출, 복사호출
    3.  함수를 호출할 때 값이 복사된다
        1. **go에서 모든 함수의 콜은 복사호출이다**
16. 함수의 호출과정과 재귀호출
    1.  함수 -> call -> jump -> 대입, 연산 -> return
    2.  재귀호출
        1.  **항상 끝나는 조건을 만들어라**
        2.  모든 재귀호출은 반복문으로 바꿀 수 있다
        3.  수학정의는 재귀호출이 쉬운 경우가 많다
    3.  **응집성은 높이고 종속성은 낮추는 것이 좋은 코딩**
17. 배열과 문자열
    1.  문자는 배열이고, 배열은 메모리다
        1.  go는 utf-8을 쓰므로 영어는 1byte, 한글은 3byte
    2.  문자열은 byte배열과 rune배열(utf-8)로 나타낼 수 있다
        1.  rune배열로 나타내면 한글도 한 글자씩 찍어낼 수 있다.
18. 배열, Radix Sort
    1.  배열의 복사
    2.  Radix sort
        1.  모든 경우에 사용할 수 없다
            1.  특정 조건
                1.  **원소 값의 범위가 한정적이고 작을 때 사용(N개)**
                    1.  이름순으로 정렬 
        2.  숫자를 작은 순부터 차례대로 카운트해서 뽑아낸다
19. 구조체
    1.  type 이름 struct{}
    2.  **객체**(개념을 한곳에 모아놓은 것)
        1.  속성
        2.  기능
    3.  goLang은 객체 밖에서 함수가 정의된다.
20. **포인터**
    1. 메모리의 ``주소``를 가르키는 것
    2. 변수가 가지는 모든 ``type``는 ``포인터``가 될 수 있다
    3. ``&``: 메모리 주소 값, ``*``: 메모리 주소가 가르키는 값
    4. 포인터가 쓰이는 이유
    5. 객체를 만들 때마다 함수의 메모리가 생성되는데 이것은 메모리의 낭비다
    6. 값을 함수인자로 받으면 함수를 복사되고, 메모리 주소를 복사하면 메모리의 주소만 복사하기 때문에 메모리가 더 적게 든다(javascript의 prototype를 이용한 객체 함수와 비슷한 개념)
21. 숫자야구 프로그래밍(code 참고)
    1. 컴퓨터가 숫자 3개를 뽑고 사용자가 숫자 3개를 입력하여서 몇 번만에 사용자가 맞추는지 계산하는 프로그램
    2. 순서도(어떤 순서대로 프로그램이 진행될지 나타내는 그림)
        1. 컴퓨터가 무작위 숫자 3개 뽑는다
        2. 사용자가 입력
        3. 비교
            1. 게임 끝
            2. 돌아가서 리게임
    3. **프로그램 만들 때 빌드가 되는 상황까지 만드는 것이 중요**
    4. 랜덤 숫자를 뽑을 때
       1. 컴퓨터는 정해진 코드대로 명령을 수행하기 때문에 랜덤 값을 뽑을 수 없다
          1. Seed 값을 설정해 줘야 한다.
             1. Time(항상 변하는 Seed 값)
22. 숫자야구2
    1.  123의 자릿 수마다 뽑아내는 방법
        1.  나머지 연산을 사용
    2.  숫자 입력을 반복할 때 ``\n``을 받아오기 때문에 없애줘야 한다.
23. Garbage Collector
    1.  메모리 쓰레기 청소부
    2.  쓰레기는 왜 생기는가
        1.  ``C언어``에서의 예시를 보자
            1.  변수 선언
                1.  ``stack 메모리``에 쌓임
            2.  프로그래머가 ``heap 메모리``에 할당(``malloc()``과 ``free()``)
                1.  메모리 할당 후 반환
                2.  **할당 받은 메모리는 반드시 지워줘야 한다.**
                    1.  참조하고 있던 변수는 사라지지만 할당받은 메모리는 지워지지 않고 어디에 존재하는지도 모른다.(``dangling``)
                        1.  쓰레기가 쌓여서 메모리 초과로 프로그램은 종료된다.
                        2.  Memory leak(흔한 버그)
                            1.  그래서 ``Garbage Collector``가 나왔다.
    3.  뭘 하나?
        1.  GC는 참조횟수(Reference Count)가 0이 되는순간 할당 메모리를 삭제한다.
            1.  참조했다 1
            2.  참조했다 2
            3.  함수 탈출 1
            4.  함수 탈출 0
            5.  삭제
        2.  ref count가 0이 아니어도 사라지지 않는 메모리
            1.  a -> b -> c -> a 의 구조
    4.  golang에서는 ``heap``과 ``stack``이 구조적으로 없다.
    5.  단점
        1.  속도가 느리다
            1.  전수조사를 하기 때문에
        2.  하지만 근래는 ``thread``가 많이 발전해서 빨라짐
    6.  **메모리를 생각하면서 프로그래밍을 하자!!**
24. Slice
    1.  동적 배열
        1.  고정 배열을 가르키고(point) 있다가 길이가 늘어나면 늘어난 배열을 가르킨다.
    2.  선언
        1.  ``var a []int``
        2.  ``a := []int{1,2,3,4}``
        3.  ``a := make([]int, 3)``
        4.  ``a := make([]int, 0, 8)``
    3.  공간: ``capacity``는 길이: ``length``는 다르다.
    4.  항목 추가
        1.  ``append(arr, element)``
            1.  기존의 arr에 항목을 추가한 것이 아니고 새로운 배열을 만들어 복사하고 반환한 것이다. 공간이 여유롭다면 이전의 배열에 추가한다.
                1.  capacity를 ``두 배``로 늘린다.
                2.  ``printf``에서 ``%p``는 주소를 찍는 것
                3.  **공간이 충분하다면 같은 메모리를 참조하게 되므로 주의할 것**
                    1.  처음부터 공간을 다르게 확보하는 것이 버그를 줄인다.
                        1.  ``copy()``
25. Slice2
    1.  ``arr[i:n]``으로 잘라낼 수 있다(``i<= ~ <n``)
        1.  ``end`` index를 생략하면 끝까지
        2.  ``start`` index를 생략하면 처음부터
        3.  ``arr1``을 잘라내서 ``arr2``를 만들었다면 새로 만든게 아니라 같은 메모리를 가르킨다.(**주의**)
        4.  하지만, 이렇게 자른다고해서 메모리가 사라지는 것이 아니다.(**주의**)
    2.  Slice 심화
        1.  동적 배열
        2.  자료구조이며 Structure를 갖고 있다
            1.  pointer: 시작 주소
            2.  len: 갯수
            3.  cap: 최대값
    3.  Instance
        1.  OOP
            1.  Teacher, input, Student  / ``관계강조``
        2.  Procedure
            1.  input(teacher, student) / ``기능강조``
26. Linked List
    1.  떨어져있는 데이터들을 연결하는 자료구조
27. Double Linked List
    1.  Linked List와 배열의 차이점
        1.  추가할 때 
            1.  Slice
                1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        2.  삭제할 때
            1.  Slice
                1.  맨 앞, 맨 끝
                    1.  ``O(1)``
                2.  중간
                    1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        3.  특정 ``index``를 가져올 때
            1.  Slice
                1.  ``O(1)``
            2.  List
                1.  ``O(N)``
        4.  데이터를 가져올 때 그 메모리 주소의 근방을 가져온다(``cache: 4kb``). 근데 list는 근처에 다음 값이 없기 때문에 ``cache miss``가 된다. 그래서 게임에서 ``배열``을 많이 쓴다.
28. Packaging과 Stack, Que
    1.  Packaging
        1.  대문자는 공개
        2.  소문자는 비공개
    2.  stack과 que는 slice와 linked list로 만들 수 있다. 
        1.  slice로 만드면
            1.  캐쉬미스가 덜나서 좋다
            2.  그리고 배열에 ``element``를 추가하면 복사하기 때문에 초반에는 연산이 오래 걸리지만, 어느정도 크기가 되면 속도가 빨라진다.
        2.  linked list
            1.  넣을 때, 뺄 때 빠르다 ``O(1)``
    3.  Stack
        1.  FILO(First Input Last Out)
    4.  Queue
        1.  FIFO(First Input First Out)
29. Tree
    1.  Node
        1.  Parent
        2.  Child
        3.  Leaf
            1.  마지막 layer
        4.  Sibiling
            1.  같은 layer
    2.  폴더 구조
    3.  **중요한 자료구조형이다. 잘 숙지하여 자유자재로 쓸 수 있을 것**
30. Tree의 순회
    1.  DFS(Depth First Search: 깊이 우선 탐색)
        1.  구현
            1.  재귀호출
            2.  스택
        2.  예
            1.  길찾기(게임): ``Dijkstra Algorithm``
    2.  BFS(Broad First Search: 너비 우선 탐색)
        1.  구현
            1.  Queue
31. 이진트리
    1.  이진 검색 트리(BST)
        1.  left: ``작음``
        2.  right: ``큼``