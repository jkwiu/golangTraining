# golangTraining

golang 복습(https://www.youtube.com/channel/UCZp_ftx6UB_32VfVmlS3o_A)

----------------------------------------------

<hr>

1. 트랜지스터
   1. 컴퓨터의 기본 요소
   2. CPU는 트랜지스터의 덩어리
   3. 기능
      1. 스위치(전기적 신호)
      2. 증폭
   4. 1bit = 트랜지스터 1
2. 논리소자
   1. 다음 연산을 트랜지스터를 만들 수 있다 = ``논리소자(가산기)`` = ``계산기``를 만들 수 있다는 의미
      1. AND
      2. OR
      3. XOR
         1. 0 1 ``1``
         2. 1 0 ``1``
         3. 0 0 ``0``
         4. 1 1 ``0``
      4. NOT
         1. 0 ``1``
         2. 1 ``0``
3. 컴퓨터
   1. 모래 -> 규소 -> 실리콘 -> 컴퓨터
   2. 튜링 테스트(튜링기계)
   3. 폰 노이만(우주 최강의 두뇌ㅋㅋ) 기계
      1. 메모리를 따로 쓰자(현대 컴퓨터)
4. 컴퓨터의 원리
   1. 컴퓨터는 명령을 순서대로 수행
   2. ``1``과 ``0``으로 이미지, 문자 등 모두 표현할 수 있다.
   3. ASCII CODE
      1. 255개 문자를 표현(256 = 0 ~ 255)
      2. 한 문자당 1byte
   4. UNICODE
      2. UTF-8(영문자/숫자: 1byte, 이외의 문자: 3byte)
      3. UTF-16(한 문자당 2byte)
   5. HDD -> CACHE -> CPU -> REGISTER(연산)
5. 프로그래밍 언어
   1. 프로그램
      1. 명령과 순서를 쓴 문서(글)
      2. 사람의 언어 -(코딩)-> 프로그래밍 언어 -(컴파일)-> 기계어
   2. 고급언어(디컴파일이 어렵다)
      1. 컴파일 언어
         1. 코딩 -> 빌드 -> 기계어
         2. C, C++
      2. 동적 언어(인터프리트 언어)
         1. 코딩 -> 빌드 -> 중간상태 -(프로그램이 동작할 때)-> 기계어
         2. JAVA, C#, PYTHON, JAVASCRIPT
   3. 어셈블리어(디컴파일이 쉽다)
   4. **프로그래머는 한가지 언어에 집착하면 안된다.**
6. 컴파일언어와 동적언어의 차이
   1. 컴파일언어
      1. 속도 빠름
      2. platform 별로 변환해야 함
   2. 동적언어
      1. 속도 느림
      2. platform 별로 변환필요 없음
7. Golang
   1. 2009년 google이 만듬
   2. system programing을 하기 위해 만듬
   3. 아버지
      1. 켄 톰슨(70세 현역)
         1. B언어의 아버지
      2. 롭 파이크
         1. UTF-8의 아부지
8. Hello World
   1. C#과 가깝다
   2. **공부를 하는 것은 페인트 칠하는 것과 비슷하다**
   3. package main
      1. 묶음
         1. 라이브러리
            1. 기능을 묶어놓은 것
         2. 모듈
            1. 기능을 묶어놓은 것(좀 더 포커싱)
         3. 패키지
            1. 기능을 묶어놓은 것
         4. 프레임 웍
            1. 기능을 묶어놓은 것(절차까지 포함)
         5. 엔진
            1. 기능과 다른 프로그램 툴까지 모두 묶어놓은 것
      2. package로 선언
      3. main
         1. 프로그램의 시작점
   4. func
      1. 함수
9. Go의 변수
   1.  속성
       1.  이름
       2.  값
       3.  TYPE
           1.  int
               1.  int32(4byte): -21억 ~ 21억
                   1. uint32: 42억
               2.  int64(8byte): 크다~~
                   1.  uint64: 크다~~
               3.  int8(1byte): -128 ~ 127
                   1.  uint8: 0 ~ 255
               4.  int16(2byte): 2에 16제곱 - 1(65535)
                   1.  uint16: 0 ~ 65535
           2.  float
               1.  숫자부와 지수부
               2.  float32
                   1.  숫자부는 7개까지 표현
               3.  float64
                   1.  15개까지
           3.  string
               1.  문자의 길이에 따라 다름
               2.  한 글자: rune: 1 ~ 3byte
           4.  bool
       4.  메모리 주소
           1.  어디서?
       5.  사이즈
           1.  어디까지 읽어올 것인가?
   2.  선언
10. Go의 변수2
11. Go의 연산자
    1.  연산자의 종류
        1.  이항 연산자
        2.  단항 연산자
    2.  Go의 연산자
        1.  산술 연산자
        2.  비트 연산자
            1.  4 & 2 = 0
            2.  3 & 2 = 2
            3.  4 | 2 = 6
        3.  논리 연산자
        4.  그 외
            1.  shift 연산자(``>>``, ``<<``)
            2.  clear 연산자
12. 조건연산자와 조건문
13. Switch-case와 반복문
    1.  tour.golang.org/welcome/1
14. For 문 예제
    1.  ch14 코드 참고
15. 함수
    1.  기능의 모듈화
    2.  참조호출, 복사호출
    3.  함수를 호출할 때 값이 복사된다
        1. **go에서 모든 함수의 콜은 복사호출이다**
16. 함수의 호출과정과 재귀호출
    1.  함수 -> call -> jump -> 대입, 연산 -> return
    2.  재귀호출
        1.  **항상 끝나는 조건을 만들어라**
        2.  모든 재귀호출은 반복문으로 바꿀 수 있다
        3.  수학정의는 재귀호출이 쉬운 경우가 많다
    3.  **응집성은 높이고 종속성은 낮추는 것이 좋은 코딩**
17. 배열과 문자열
    1.  문자는 배열이고, 배열은 메모리다
        1.  go는 utf-8을 쓰므로 영어는 1byte, 한글은 3byte
    2.  문자열은 byte배열과 rune배열(utf-8)로 나타낼 수 있다
        1.  rune배열로 나타내면 한글도 한 글자씩 찍어낼 수 있다.
18. 배열, Radix Sort
    1.  배열의 복사
    2.  Radix sort
        1.  모든 경우에 사용할 수 없다
            1.  특정 조건
                1.  **원소 값의 범위가 한정적이고 작을 때 사용(N개)**
                    1.  이름순으로 정렬 
        2.  숫자를 작은 순부터 차례대로 카운트해서 뽑아낸다
19. 구조체
    1.  type 이름 struct{}
    2.  **객체**(개념을 한곳에 모아놓은 것)
        1.  속성
        2.  기능
    3.  goLang은 객체 밖에서 함수가 정의된다.
20. **포인터**
    1. 메모리의 ``주소``를 가르키는 것
    2. 변수가 가지는 모든 ``type``는 ``포인터``가 될 수 있다
    3. ``&``: 메모리 주소 값, ``*``: 메모리 주소가 가르키는 값
    4. 포인터가 쓰이는 이유
    5. 객체를 만들 때마다 함수의 메모리가 생성되는데 이것은 메모리의 낭비다
    6. 값을 함수인자로 받으면 함수를 복사되고, 메모리 주소를 복사하면 메모리의 주소만 복사하기 때문에 메모리가 더 적게 든다(javascript의 prototype를 이용한 객체 함수와 비슷한 개념)
    7. c++의 ``참조변수``와 다르다. ``golang``에서는 말 그대로 변수가 저장된 주소값을 포인터로 선언하면 그 주소를 가르키는 메모리를 새로 할당한다.
21. 숫자야구 프로그래밍(code 참고)
    1. 컴퓨터가 숫자 3개를 뽑고 사용자가 숫자 3개를 입력하여서 몇 번만에 사용자가 맞추는지 계산하는 프로그램
    2. 순서도(어떤 순서대로 프로그램이 진행될지 나타내는 그림)
        1. 컴퓨터가 무작위 숫자 3개 뽑는다
        2. 사용자가 입력
        3. 비교
            1. 게임 끝
            2. 돌아가서 리게임
    3. **프로그램 만들 때 빌드가 되는 상황까지 만드는 것이 중요**
    4. 랜덤 숫자를 뽑을 때
       1. 컴퓨터는 정해진 코드대로 명령을 수행하기 때문에 랜덤 값을 뽑을 수 없다
          1. Seed 값을 설정해 줘야 한다.
             1. Time(항상 변하는 Seed 값)
22. 숫자야구2
    1.  123의 자릿 수마다 뽑아내는 방법
        1.  나머지 연산을 사용
    2.  숫자 입력을 반복할 때 ``\n``을 받아오기 때문에 없애줘야 한다.
23. Garbage Collector
    1.  메모리 쓰레기 청소부
    2.  쓰레기는 왜 생기는가
        1.  ``C언어``에서의 예시를 보자
            1.  변수 선언
                1.  ``stack 메모리``에 쌓임
            2.  프로그래머가 ``heap 메모리``에 할당(``malloc()``과 ``free()``)
                1.  메모리 할당 후 반환
                2.  **할당 받은 메모리는 반드시 지워줘야 한다.**
                    1.  참조하고 있던 변수는 사라지지만 할당받은 메모리는 지워지지 않고 어디에 존재하는지도 모른다.(``dangling``)
                        1.  쓰레기가 쌓여서 메모리 초과로 프로그램은 종료된다.
                        2.  Memory leak(흔한 버그)
                            1.  그래서 ``Garbage Collector``가 나왔다.
    3.  뭘 하나?
        1.  GC는 참조횟수(Reference Count)가 0이 되는순간 할당 메모리를 삭제한다.
            1.  참조했다 1
            2.  참조했다 2
            3.  함수 탈출 1
            4.  함수 탈출 0
            5.  삭제
        2.  ref count가 0이 아니어도 사라지지 않는 메모리
            1.  a -> b -> c -> a 의 구조
    4.  golang에서는 ``heap``과 ``stack``이 구조적으로 없다.
    5.  단점
        1.  속도가 느리다
            1.  전수조사를 하기 때문에
        2.  하지만 근래는 ``thread``가 많이 발전해서 빨라짐
    6.  **메모리를 생각하면서 프로그래밍을 하자!!**
24. Slice
    1.  동적 배열
        1.  고정 배열을 가르키고(point) 있다가 길이가 늘어나면 늘어난 배열을 가르킨다.
    2.  선언
        1.  ``var a []int``
        2.  ``a := []int{1,2,3,4}``
        3.  ``a := make([]int, 3)``
        4.  ``a := make([]int, 0, 8)``
    3.  공간: ``capacity``는 길이: ``length``는 다르다.
    4.  항목 추가
        1.  ``append(arr, element)``
            1.  기존의 arr에 항목을 추가한 것이 아니고 새로운 배열을 만들어 복사하고 반환한 것이다. 공간이 여유롭다면 이전의 배열에 추가한다.
                1.  capacity를 ``두 배``로 늘린다.
                2.  ``printf``에서 ``%p``는 주소를 찍는 것
                3.  **공간이 충분하다면 같은 메모리를 참조하게 되므로 주의할 것**
                    1.  처음부터 공간을 다르게 확보하는 것이 버그를 줄인다.
                        1.  ``copy()``
25. Slice2
    1.  ``arr[i:n]``으로 잘라낼 수 있다(``i<= ~ <n``)
        1.  ``end`` index를 생략하면 끝까지
        2.  ``start`` index를 생략하면 처음부터
        3.  ``arr1``을 잘라내서 ``arr2``를 만들었다면 새로 만든게 아니라 같은 메모리를 가르킨다.(**주의**)
        4.  하지만, 이렇게 자른다고해서 메모리가 사라지는 것이 아니다.(**주의**)
    2.  Slice 심화
        1.  동적 배열
        2.  자료구조이며 Structure를 갖고 있다
            1.  pointer: 시작 주소
            2.  len: 갯수
            3.  cap: 최대값
    3.  Instance
        1.  OOP
            1.  Teacher, input, Student  / ``관계강조``
        2.  Procedure
            1.  input(teacher, student) / ``기능강조``
26. Linked List
    1.  떨어져있는 데이터들을 연결하는 자료구조
27. Double Linked List
    1.  Linked List와 배열의 차이점
        1.  추가할 때 
            1.  Slice
                1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        2.  삭제할 때
            1.  Slice
                1.  맨 앞, 맨 끝
                    1.  ``O(1)``
                2.  중간
                    1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        3.  특정 ``index``를 가져올 때
            1.  Slice
                1.  ``O(1)``
            2.  List
                1.  ``O(N)``
        4.  데이터를 가져올 때 그 메모리 주소의 근방을 가져온다(``cache: 4kb``). 근데 list는 근처에 다음 값이 없기 때문에 ``cache miss``가 된다. 그래서 게임에서 ``배열``을 많이 쓴다.
28. Packaging과 Stack, Que
    1.  Packaging
        1.  대문자는 공개
        2.  소문자는 비공개
    2.  stack과 que는 slice와 linked list로 만들 수 있다. 
        1.  slice로 만드면
            1.  캐쉬미스가 덜나서 좋다
            2.  그리고 배열에 ``element``를 추가하면 복사하기 때문에 초반에는 연산이 오래 걸리지만, 어느정도 크기가 되면 속도가 빨라진다.
        2.  linked list
            1.  넣을 때, 뺄 때 빠르다 ``O(1)``
    3.  Stack
        1.  FILO(First Input Last Out)
    4.  Queue
        1.  FIFO(First Input First Out)
29. Tree
    1.  Node
        1.  Parent
        2.  Child
        3.  Leaf
            1.  마지막 layer
        4.  Sibiling
            1.  같은 layer
    2.  폴더 구조
    3.  **중요한 자료구조형이다. 잘 숙지하여 자유자재로 쓸 수 있을 것**
30. Tree의 순회
    1.  DFS(Depth First Search: 깊이 우선 탐색)
        1.  구현
            1.  재귀호출
            2.  스택
        2.  예
            1.  길찾기(게임): ``Dijkstra Algorithm``
    2.  BFS(Broad First Search: 너비 우선 탐색)
        1.  구현
            1.  Queue
31. 이진트리
    1.  두개의 노드를 가지는 트리
32. 이진 검색 트리(BST)
    1.  left: ``작음``
    2.  right: ``큼``
    3.  가운데의 값이 ``root``가 되는 형태가 가장 효율적인 형태(``최소신장트리``)
    4.  AVL 트리
        1.  회전을 하여 최소신장트리가 되게 한다.
33. Heap
    1.  최대힙
        1.  부모노드가 자식노드보다 크거나 같아야 한다.
    2.  최소힙
        1.  부모노드가 자식노드보다 작거나 같아야 한다.
    3.  Heap은 어디에 쓰이는가?
        1.  최대값과 최소값을 찾을 때
        2.  우선순위 큐(priority queue)
            1.  응급실의 큐
            2.  프린터 대기열 큐
        3.  힙 정렬
            1.  오름차순, 내림차순
    4.  방법
        1.  항목추가
            1.  최하단 노드에 추가하고 부모와 비교하여 크거나 작으면 하나씩 올리거나 내린다.
        2.  항목빼기
            1.  최상단 노드부터 빠진다.
            2.  최하단 노드를 맨 위로 올리고 자식 노드와 비교하여 크거나 작으면 올리거나 내린다.
    5.  속도
        1.  push
            1.  가지고 있는 층 수에 비례
                1.  가지고 있는 항목 수 / 2
                    1.  반 씩 짤려 나간다.
                    2.  ``O(log``<sub>2</sub>``N)``
        2.  pop
            1.  ``O(log``<sub>2</sub>``N)``
        3.  힙정렬
            1.  ``O(2Nlog2N)``인데 비고법에서 뒤의 ``N``이 매우 크면 2는 의미가 없어지므로 삭제
                1.  ``O(Nlog``<sub>2</sub>``N)``
34. Heap2
    1.  Tree로 만들기 힘들다. 왜냐면 층에서 가장 마지막 노드를 알아야 하기 때문에,,
        1.  그래서 ``slice``로 구현
    2.  구현
        1.  ``배열``에 ``BFS``로 넣는다
        2.  N번째의
            1.  left: 2N+1
            2.  right: 2N+2
        3.  N번째 노드의 부모
            1.  N-1/2
        4.  최대합
            1.  Push
                1.  위에서부터 아래로 비교하면서 스왑
            2.  Pop
                1.  아래서부터 위로 비교하면서 스왑
35. Heap을 이용한 알고리즘 풀이
    1.  문제
        1.  정수배열과 정수 N이 주어지면, N번째로 큰 배열 원소를 찾으시오
    2.  해답
        1.  소스참고
        2.  일반적인 풀이는 원소가 매우 큰 경우에 문제가 될 수 있으므로
36. Map(Dictionary, hash table)과 Hash의 관계
    1.  ``key``, ``value``
    2.  구현방법과 속도의 차이
        1.  slice로 만들면 비효율 ``O(N)``
        2.  BST로 만들면 효율적이다(sorted map, ordered map) ``O(log``<sub>2</sub>``N)``
        3.  Hash Map ``O(1)``
    3.  Hash의 특징
        1.  출력 값의 범위가 한정되어야 한다.
            1.  범위를 정하려면 어떻게 할까?
                1.  ``sin함수``
                    1.  출력값 범위
                        1.  ``-1`` ~ ``1``
                    2.  정수 -> 실수
                2.  ``Modular`` (나머지 연산)
                    1.  출력값 범위
                        1.  ``0`` ~ ``(N-1)``
                    2.  정수 -> 정수
                    3.  One-way Function
                        1.  mod12를 해서 나머지가 3이 나오는 x는 무엇인가??
                            1.  무수히 많고 알 수 없다
                        2.  **즉 암호화가 가능하다는 뜻**
                            1.  쓰이는 곳
                                1.  공개키 암호화
                                2.  check sum
                                3.  블록체인
        2.  같은입력 -> 같은출력
        3.  다른입력 ->보통의 경우(아닌 경우도 있는데 좀 어려움,,)-> 다른출력
37. Map 구현
    1.  Rolling Hash
        1.  구현
            1.  ``S``<sub>0</sub>``...S``<sub>n</sub> 일 때(S는 문자에 해당하는 키 값: ASCII코드를 사용하므로 0 ~ 255)
                1.  ``H``<sub>i</sub> ``= (H``<sub>i-1</sub> ``* A + S``<sub>i</sub>``)/B``를 A와 B를 지정하고 0부터 n까지 반복
                    1.  A값
                        1.  S가 ASCII로 0 ~ 255므로 더 큰 값 으로 하는게 좋다.
                            1.  ex
                                1.  256
                    2.  B값
                        1.  나머지 연산을 할 때 ``소수``로 잡으면 값의 분포가 넓게 퍼지기 때문에 좋다.
                        2.  ex
                            1.  3571
                                1.  문제점
                                    1.  이렇게 하면 0 ~ 3570 범위의 출력이 나온다.
                                        1.  하지만, 이리하면 ``손실압축``이 발생한다.
                                            1.  문자열 무한대 ->입력-> Hash Function ->출력-> 0~3570
                                    2.  다른입력 -> 같은출력이 나올 수 있다.
                                        1.  이 경우 배열 안에 배열을 넣어서 다른입력->같은출력의 오류를 방지한다.
                2.  나머지는 코드 참조
            2.  배열을 만들고 ``key``, ``value``로 저장
    2.  Map은 List와 마찬가지로 가장 많이 사용되는 자료구조형이다.
    3.  장점
        1.  빠르다
            1.  Find
                1.  ``O(1)``
            2.  Add
                1.  ``O(1)``
            3.  Remov
                1.  ``O(1)``
    4.  단점
        1.  정렬해서 뽑아내기 어렵다.
            1.  이런 경우 sorted map을 사용하지만 add, remove가 ``O(log``<sub>2</sub>``N)`` 왜냐하면 BST를 사용하니깐