# golangTraining

golang 복습(https://www.youtube.com/channel/UCZp_ftx6UB_32VfVmlS3o_A)

----------------------------------------------

<hr>

1. 트랜지스터
   1. 컴퓨터의 기본 요소
   2. CPU는 트랜지스터의 덩어리
   3. 기능
      1. 스위치(전기적 신호)
      2. 증폭
   4. 1bit = 트랜지스터 1
2. 논리소자
   1. 다음 연산을 트랜지스터를 만들 수 있다 = ``논리소자(가산기)`` = ``계산기``를 만들 수 있다는 의미
      1. AND
      2. OR
      3. XOR
         1. 0 1 ``1``
         2. 1 0 ``1``
         3. 0 0 ``0``
         4. 1 1 ``0``
      4. NOT
         1. 0 ``1``
         2. 1 ``0``
3. 컴퓨터
   1. 모래 -> 규소 -> 실리콘 -> 컴퓨터
   2. 튜링 테스트(튜링기계)
   3. 폰 노이만(우주 최강의 두뇌ㅋㅋ) 기계
      1. 메모리를 따로 쓰자(현대 컴퓨터)
4. 컴퓨터의 원리
   1. 컴퓨터는 명령을 순서대로 수행
   2. ``1``과 ``0``으로 이미지, 문자 등 모두 표현할 수 있다.
   3. ASCII CODE
      1. 255개 문자를 표현(256 = 0 ~ 255)
      2. 한 문자당 1byte
   4. UNICODE
      2. UTF-8(영문자/숫자: 1byte, 이외의 문자: 3byte)
      3. UTF-16(한 문자당 2byte)
   5. HDD -> CACHE -> CPU -> REGISTER(연산)
5. 프로그래밍 언어
   1. 프로그램
      1. 명령과 순서를 쓴 문서(글)
      2. 사람의 언어 -(코딩)-> 프로그래밍 언어 -(컴파일)-> 기계어
   2. 고급언어(디컴파일이 어렵다)
      1. 컴파일 언어
         1. 코딩 -> 빌드 -> 기계어
         2. C, C++
      2. 동적 언어(인터프리트 언어)
         1. 코딩 -> 빌드 -> 중간상태 -(프로그램이 동작할 때)-> 기계어
         2. JAVA, C#, PYTHON, JAVASCRIPT
   3. 어셈블리어(디컴파일이 쉽다)
   4. **프로그래머는 한가지 언어에 집착하면 안된다.**
6. 컴파일언어와 동적언어의 차이
   1. 컴파일언어
      1. 속도 빠름
      2. platform 별로 변환해야 함
   2. 동적언어
      1. 속도 느림
      2. platform 별로 변환필요 없음
7. Golang
   1. 2009년 google이 만듬
   2. system programing을 하기 위해 만듬
   3. 아버지
      1. 켄 톰슨(70세 현역)
         1. B언어의 아버지
      2. 롭 파이크
         1. UTF-8의 아부지
8. Hello World
   1. C#과 가깝다
   2. **공부를 하는 것은 페인트 칠하는 것과 비슷하다**
   3. package main
      1. 묶음
         1. 라이브러리
            1. 기능을 묶어놓은 것
         2. 모듈
            1. 기능을 묶어놓은 것(좀 더 포커싱)
         3. 패키지
            1. 기능을 묶어놓은 것
         4. 프레임 웍
            1. 기능을 묶어놓은 것(절차까지 포함)
         5. 엔진
            1. 기능과 다른 프로그램 툴까지 모두 묶어놓은 것
      2. package로 선언
      3. main
         1. 프로그램의 시작점
   4. func
      1. 함수
9. Go의 변수
   1.  속성
       1.  이름
       2.  값
       3.  TYPE
           1.  int
               1.  int32(4byte): -21억 ~ 21억
                   1. uint32: 42억
               2.  int64(8byte): 크다~~
                   1.  uint64: 크다~~
               3.  int8(1byte): -128 ~ 127
                   1.  uint8: 0 ~ 255
               4.  int16(2byte): 2에 16제곱 - 1(65535)
                   1.  uint16: 0 ~ 65535
           2.  float
               1.  숫자부와 지수부
               2.  float32
                   1.  숫자부는 7개까지 표현
               3.  float64
                   1.  15개까지
           3.  string
               1.  문자의 길이에 따라 다름
               2.  한 글자: rune: 1 ~ 3byte
           4.  bool
       4.  메모리 주소
           1.  어디서?
       5.  사이즈
           1.  어디까지 읽어올 것인가?
   2.  선언
10. Go의 변수2
11. Go의 연산자
    1.  연산자의 종류
        1.  이항 연산자
        2.  단항 연산자
    2.  Go의 연산자
        1.  산술 연산자
        2.  비트 연산자
            1.  4 & 2 = 0
            2.  3 & 2 = 2
            3.  4 | 2 = 6
        3.  논리 연산자
        4.  그 외
            1.  shift 연산자(``>>``, ``<<``)
            2.  clear 연산자
12. 조건연산자와 조건문
13. Switch-case와 반복문
    1.  tour.golang.org/welcome/1
14. For 문 예제
    1.  ch14 코드 참고
15. 함수
    1.  기능의 모듈화
    2.  참조호출, 복사호출
    3.  함수를 호출할 때 값이 복사된다
        1. **go에서 모든 함수의 콜은 복사호출이다**
16. 함수의 호출과정과 재귀호출
    1.  함수 -> call -> jump -> 대입, 연산 -> return
    2.  재귀호출
        1.  **항상 끝나는 조건을 만들어라**
        2.  모든 재귀호출은 반복문으로 바꿀 수 있다
        3.  수학정의는 재귀호출이 쉬운 경우가 많다
    3.  **응집성은 높이고 종속성은 낮추는 것이 좋은 코딩**
17. 배열과 문자열
    1.  문자는 배열이고, 배열은 메모리다
        1.  go는 utf-8을 쓰므로 영어는 1byte, 한글은 3byte
    2.  문자열은 byte배열과 rune배열(utf-8)로 나타낼 수 있다
        1.  rune배열로 나타내면 한글도 한 글자씩 찍어낼 수 있다.
18. 배열, Radix Sort
    1.  배열의 복사
    2.  Radix sort
        1.  모든 경우에 사용할 수 없다
            1.  특정 조건
                1.  **원소 값의 범위가 한정적이고 작을 때 사용(N개)**
                    1.  이름순으로 정렬 
        2.  숫자를 작은 순부터 차례대로 카운트해서 뽑아낸다
19. 구조체
    1.  type 이름 struct{}
    2.  **객체**(개념을 한곳에 모아놓은 것)
        1.  속성
        2.  기능
    3.  goLang은 객체 밖에서 함수가 정의된다.
20. **포인터**
    1. 메모리의 ``주소``를 가르키는 것
    2. 변수가 가지는 모든 ``type``는 ``포인터``가 될 수 있다
    3. ``&``: 메모리 주소 값, ``*``: 메모리 주소가 가르키는 값
    4. 포인터가 쓰이는 이유
    5. 객체를 만들 때마다 함수의 메모리가 생성되는데 이것은 메모리의 낭비다
    6. 값을 함수인자로 받으면 함수를 복사되고, 메모리 주소를 복사하면 메모리의 주소만 복사하기 때문에 메모리가 더 적게 든다(javascript의 prototype를 이용한 객체 함수와 비슷한 개념)
    7. c++의 ``참조변수``와 다르다. ``golang``에서는 말 그대로 변수가 저장된 주소값을 포인터로 선언하면 그 주소를 가르키는 메모리를 새로 할당한다.
21. 숫자야구 프로그래밍(code 참고)
    1. 컴퓨터가 숫자 3개를 뽑고 사용자가 숫자 3개를 입력하여서 몇 번만에 사용자가 맞추는지 계산하는 프로그램
    2. 순서도(어떤 순서대로 프로그램이 진행될지 나타내는 그림)
        1. 컴퓨터가 무작위 숫자 3개 뽑는다
        2. 사용자가 입력
        3. 비교
            1. 게임 끝
            2. 돌아가서 리게임
    3. **프로그램 만들 때 빌드가 되는 상황까지 만드는 것이 중요**
    4. 랜덤 숫자를 뽑을 때
       1. 컴퓨터는 정해진 코드대로 명령을 수행하기 때문에 랜덤 값을 뽑을 수 없다
          1. Seed 값을 설정해 줘야 한다.
             1. Time(항상 변하는 Seed 값)
22. 숫자야구2
    1.  123의 자릿 수마다 뽑아내는 방법
        1.  나머지 연산을 사용
    2.  숫자 입력을 반복할 때 ``\n``을 받아오기 때문에 없애줘야 한다.
23. Garbage Collector
    1.  메모리 쓰레기 청소부
    2.  쓰레기는 왜 생기는가
        1.  ``C언어``에서의 예시를 보자
            1.  변수 선언
                1.  ``stack 메모리``에 쌓임
            2.  프로그래머가 ``heap 메모리``에 할당(``malloc()``과 ``free()``)
                1.  메모리 할당 후 반환
                2.  **할당 받은 메모리는 반드시 지워줘야 한다.**
                    1.  참조하고 있던 변수는 사라지지만 할당받은 메모리는 지워지지 않고 어디에 존재하는지도 모른다.(``dangling``)
                        1.  쓰레기가 쌓여서 메모리 초과로 프로그램은 종료된다.
                        2.  Memory leak(흔한 버그)
                            1.  그래서 ``Garbage Collector``가 나왔다.
    3.  뭘 하나?
        1.  GC는 참조횟수(Reference Count)가 0이 되는순간 할당 메모리를 삭제한다.
            1.  참조했다 1
            2.  참조했다 2
            3.  함수 탈출 1
            4.  함수 탈출 0
            5.  삭제
        2.  ref count가 0이 아니어도 사라지지 않는 메모리
            1.  a -> b -> c -> a 의 구조
    4.  golang에서는 ``heap``과 ``stack``이 구조적으로 없다.
    5.  단점
        1.  속도가 느리다
            1.  전수조사를 하기 때문에
        2.  하지만 근래는 ``thread``가 많이 발전해서 빨라짐
    6.  **메모리를 생각하면서 프로그래밍을 하자!!**
24. Slice
    1.  동적 배열
        1.  고정 배열을 가르키고(point) 있다가 길이가 늘어나면 늘어난 배열을 가르킨다.
    2.  선언
        1.  ``var a []int``
        2.  ``a := []int{1,2,3,4}``
        3.  ``a := make([]int, 3)``
        4.  ``a := make([]int, 0, 8)``
    3.  공간: ``capacity``는 길이: ``length``는 다르다.
    4.  항목 추가
        1.  ``append(arr, element)``
            1.  기존의 arr에 항목을 추가한 것이 아니고 새로운 배열을 만들어 복사하고 반환한 것이다. 공간이 여유롭다면 이전의 배열에 추가한다.
                1.  capacity를 ``두 배``로 늘린다.
                2.  ``printf``에서 ``%p``는 주소를 찍는 것
                3.  **공간이 충분하다면 같은 메모리를 참조하게 되므로 주의할 것**
                    1.  처음부터 공간을 다르게 확보하는 것이 버그를 줄인다.
                        1.  ``copy()``
25. Slice2
    1.  ``arr[i:n]``으로 잘라낼 수 있다(``i<= ~ <n``)
        1.  ``end`` index를 생략하면 끝까지
        2.  ``start`` index를 생략하면 처음부터
        3.  ``arr1``을 잘라내서 ``arr2``를 만들었다면 새로 만든게 아니라 같은 메모리를 가르킨다.(**주의**)
        4.  하지만, 이렇게 자른다고해서 메모리가 사라지는 것이 아니다.(**주의**)
    2.  Slice 심화
        1.  동적 배열
        2.  자료구조이며 Structure를 갖고 있다
            1.  pointer: 시작 주소
            2.  len: 갯수
            3.  cap: 최대값
    3.  Instance
        1.  OOP
            1.  Teacher, input, Student  / ``관계강조``
        2.  Procedure
            1.  input(teacher, student) / ``기능강조``
26. Linked List
    1.  떨어져있는 데이터들을 연결하는 자료구조
27. Double Linked List
    1.  Linked List와 배열의 차이점
        1.  추가할 때 
            1.  Slice
                1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        2.  삭제할 때
            1.  Slice
                1.  맨 앞, 맨 끝
                    1.  ``O(1)``
                2.  중간
                    1.  ``O(N)``
            2.  List
                1.  ``O(1)``
        3.  특정 ``index``를 가져올 때
            1.  Slice
                1.  ``O(1)``
            2.  List
                1.  ``O(N)``
        4.  데이터를 가져올 때 그 메모리 주소의 근방을 가져온다(``cache: 4kb``). 근데 list는 근처에 다음 값이 없기 때문에 ``cache miss``가 된다. 그래서 게임에서 ``배열``을 많이 쓴다.
28. Packaging과 Stack, Que
    1.  Packaging
        1.  대문자는 공개
        2.  소문자는 비공개
    2.  stack과 queue는 slice와 linked list로 만들 수 있다. 
        1.  slice로 만드면
            1.  캐쉬미스가 덜나서 좋다
            2.  그리고 배열에 ``element``를 추가하면 복사하기 때문에 초반에는 연산이 오래 걸리지만, 어느정도 크기가 되면 속도가 빨라진다.
                1.  왜냐하면 배열이 추가될 때는 capacity를 2배로 늘리고 추가를 하게 되는데, 배열이 1개일 때는 2개로 늘리고 복사한다. 그런데 배열이 어느정도 성장한 뒤에는 크기가 충분히 커져있기 때문에 O(N)이라고는 하지만 실제 성능은 잘 나온다. 그래도 O(1)보다는 느리다. 그리고 slice로 했을 때 캐쉬미스가 덜 나기 때문에 성능상으로 더 빠를 수 있다.
        2.  linked list
            1.  넣을 때, 뺄 때 빠르다 ``O(1)``
    3.  Stack
        1.  FILO(First Input Last Out)
    4.  Queue
        1.  FIFO(First Input First Out)
29. Tree
    1.  Node
        1.  Parent
        2.  Child
        3.  Leaf
            1.  마지막 layer의 Node
        4.  Sibiling
            1.  같은 layer(형제 Node)
    2.  폴더 구조
    3.  **중요한 자료구조형이다. 잘 숙지하여 자유자재로 쓸 수 있을 것**
30. Tree의 순회
    1.  DFS(Depth First Search: 깊이 우선 탐색)
        1.  구현
            1.  재귀호출
            2.  스택
        2.  예
            1.  길찾기(게임): ``Dijkstra Algorithm``
    2.  BFS(Broad First Search: 너비 우선 탐색)
        1.  구현
            1.  Queue
31. 이진트리
    1.  두개의 노드를 가지는 트리
32. 이진 검색 트리(BST)
    1.  left: ``작음``
    2.  right: ``큼``
    3.  가운데의 값이 ``root``가 되는 형태가 가장 효율적인 형태(``최소신장트리``)
    4.  AVL 트리
        1.  회전을 하여 최소신장트리가 되게 한다.
33. Heap
    1.  최대힙
        1.  부모노드가 자식노드보다 크거나 같아야 한다.
    2.  최소힙
        1.  부모노드가 자식노드보다 작거나 같아야 한다.
    3.  Heap은 어디에 쓰이는가?
        1.  최대값과 최소값을 찾을 때
        2.  우선순위 큐(priority queue)
            1.  응급실의 큐
            2.  프린터 대기열 큐
        3.  힙 정렬
            1.  오름차순, 내림차순
    4.  방법
        1.  항목추가
            1.  최하단 노드에 추가하고 부모와 비교하여 크거나 작으면 하나씩 올리거나 내린다.
        2.  항목빼기
            1.  최상단 노드부터 빠진다.
            2.  최하단 노드를 맨 위로 올리고 자식 노드와 비교하여 크거나 작으면 올리거나 내린다.
    5.  속도
        1.  push
            1.  가지고 있는 층 수에 비례
                1.  가지고 있는 항목 수 / 2
                    1.  반 씩 짤려 나간다.
                    2.  ``O(log``<sub>2</sub>``N)``
        2.  pop
            1.  ``O(log``<sub>2</sub>``N)``
        3.  힙정렬
            1.  ``O(2Nlog2N)``인데 비고법에서 뒤의 ``N``이 매우 크면 2는 의미가 없어지므로 삭제
                1.  ``O(Nlog``<sub>2</sub>``N)``
34. Heap2
    1.  Tree로 만들기 힘들다. 왜냐면 층에서 가장 마지막 노드를 알아야 하기 때문에,,
        1.  그래서 ``slice``로 구현
    2.  구현
        1.  ``배열``에 ``BFS``로 넣는다
        2.  N번째의
            1.  left: 2N+1
            2.  right: 2N+2
        3.  N번째 노드의 부모
            1.  N-1/2
        4.  최대힙, 최소힙
            1.  Push
                1.  맨 끝(아래)에 넣고 부모와 비교하면서 위로 올린다.
            2.  Pop
                1.  맨 위를 빼고 다시 맨 끝(아래)을 맨 위로 올려서 비교하면서 내려간다.
35. Heap을 이용한 알고리즘 풀이
    1.  문제
        1.  정수배열과 정수 N이 주어지면, N번째로 큰 배열 원소를 찾으시오
    2.  해답
        1.  소스참고
        2.  일반적인 풀이는 원소가 매우 큰 경우에 문제가 될 수 있으므로
36. Map(Dictionary, hash table)과 Hash의 관계
    1.  ``key``, ``value``
    2.  구현방법과 속도의 차이
        1.  slice로 만들면 비효율 ``O(N)``
        2.  BST로 만들면 효율적이다(sorted map, ordered map) ``O(log``<sub>2</sub>``N)``
        3.  Hash Map ``O(1)``
    3.  Hash의 특징
        1.  출력 값의 범위가 한정되어야 한다.
            1.  범위를 정하려면 어떻게 할까?
                1.  ``sin함수``
                    1.  출력값 범위
                        1.  ``-1`` ~ ``1``
                    2.  정수 -> 실수
                2.  ``Modular`` (나머지 연산)
                    1.  출력값 범위
                        1.  ``0`` ~ ``(N-1)``
                    2.  정수 -> 정수
                    3.  One-way Function
                        1.  mod12를 해서 나머지가 3이 나오는 x는 무엇인가??
                            1.  무수히 많고 알 수 없다
                        2.  **즉 암호화가 가능하다는 뜻**
                            1.  쓰이는 곳
                                1.  공개키 암호화
                                2.  check sum
                                3.  블록체인
        2.  같은입력 -> 같은출력
        3.  다른입력 ->보통의 경우(아닌 경우도 있는데 좀 어려움,,)-> 다른출력
37. Map 구현
    1.  Rolling Hash
        1.  구현
            1.  ``S``<sub>0</sub>``...S``<sub>n</sub> 일 때(S는 문자에 해당하는 키 값: ASCII코드를 사용하므로 0 ~ 255)
                1.  ``H``<sub>i</sub> ``= (H``<sub>i-1</sub> ``* A + S``<sub>i</sub>``)/B``를 A와 B를 지정하고 0부터 n까지 반복
                    1.  A값
                        1.  S가 ASCII로 0 ~ 255므로 더 큰 값 으로 하는게 좋다.
                            1.  ex
                                1.  256
                    2.  B값
                        1.  나머지 연산을 할 때 ``소수``로 잡으면 값의 분포가 넓게 퍼지기 때문에 좋다.
                        2.  ex
                            1.  3571
                                1.  문제점
                                    1.  이렇게 하면 0 ~ 3570 범위의 출력이 나온다.
                                        1.  하지만, 이리하면 ``손실압축``이 발생한다.
                                            1.  문자열 무한대 ->입력-> Hash Function ->출력-> 0~3570
                                    2.  다른입력 -> 같은출력이 나올 수 있다.
                                        1.  이 경우 배열 안에 배열을 넣어서 다른입력->같은출력의 오류를 방지한다.
                2.  나머지는 코드 참조
            2.  배열을 만들고 ``key``, ``value``로 저장
    2.  Map은 List와 마찬가지로 가장 많이 사용되는 자료구조형이다.
    3.  장점
        1.  빠르다
            1.  Find
                1.  ``O(1)``
            2.  Add
                1.  ``O(1)``
            3.  Remove
                1.  ``O(1)``
    4.  단점
        1.  정렬해서 뽑아내기 어렵다.
            1.  이런 경우 sorted map을 사용하지만 add, remove가 ``O(log``<sub>2</sub>``N)`` 왜냐하면 BST를 사용하니깐
38. GoLang의 Map
    1.  사용방법
        1.  선언
            1.  ``var 변수 map[타입]타입``
            2.  아무타입이나 다 가능
        2.  초기화
            1.  ``변수 = make(map[타입]타입)``
        3.  삭제
            1.  ``DELETE(map이름, key)``
        4.  순회
            1.  ``for key, value := range map {print(key, value)}``
    2.  기본값
        1.  int
            1.  ``0``
        2.  string
            1.  ``""``
        3.  bool
            1.  ``false``
        4.  이러면 내가 기본값으로 한건지, 해당 값으로 한건지 알 수가 없다.
            1.  ``변수, ok(bool) := map[key]``을 하여 출력을 했을 때 값이 빈값이면 ``ok``가 ``false``를 출력
                1.  순서는 무작위로 나옴. 전 강의에서 설명했음.
39. Thread
    1.  현대 프로그래밍에서 중요한 프로그래밍 기술이고 어렵다
    2.  웹개발은 필요x
    3.  시스템이나 게임서버는 필수
    4.  context thread
        1.  한 프로세스를 실행하다가 다른 프로세스를 실행할 때 일어나는 cpu의 process 전환
    5.  스레드를 너무 많이 만들기 되면 context switching 비용이 많이 들어 비효율적이다.
    6.  OS영역의 kernel thread ->wraping-> go thread
    7.  os thread를 최소한으로 사용하고 그걸 잘게 쪼개서 사용하는 것이 go thread(context switching을 최대한 안일어나게 하기 위해 고안함) 
    8.  cpu갯수보다 thread 갯수가 많아지면 context switching이 일어난다.
    9.  cpu 갯수에 가깝게 thread를 만들고
    10. 각 thread를 잘게 쪼개서 go thread에 할당한다.
    11. 따라서 go thread는 사용자가 cpu의 thread를 신경쓰지 않아도 된다.
40. Thread2
    1.  용어 차이
        1.  프로그램(실행파일 + 데이터)
            1.  쓰레드
                1.  프로세스
    2.  프로그램 실행하면
        1.  메모리에 올린다(프로세스)
        2.  OS가 I.P를 CPU를 통해 실행한다.(쓰레드 여러개 가질 수 있다.)
        3.  **현대 프로그램은 여러개의 쓰레드를 쓰는 것이 기본이다**
    3.  단점
        1.  데이터 동기화 문제
            1.  한 백지에 두명이 동시에 그림을 그리면 엉망진창이 된다.
            2.  대표적인 예
                1.  은행 송금 문제(코드 참고)
                    1.  ``a.balance -= val`` 은 한 줄의 연산이지만 
                        1.  실제로 cpu가 ``register``에 보내면서 하는 연산은
                            1.  Load registerA a.balance
                            2.  Load registerB val
                            3.  (감산기로 보냄)Del registerA registerB, &a.balance
                        2.  세 개의 연산인 것이다..
                        3.  그러므로 cpu여러개가 연산을 같은 메모리에 동시수행할 때 데이터가 꼬인다.
            3.  해결방법
                1.  ``Lock``을 건다.
                    1.  내가 그림을 그릴 때 락, 니가 그릴 때 락
                    2.  ``Mutex``
                        1.  실제로 실무에서 어디에 lock을 걸어줘야할지 모르는 복잡한 문제가 발생
                        2.  실제 다루는 데이터를 중점으로 건다.
                2.  go channel
41. DeadLock & Channel
    1.  DeadLock
        1.  철학자의 식사시간
            1.  왼쪽 lock(포크)을 잡고 오른쪽 lock(포크)을 잡으려고 하는데 모두 그럴려고 대기중이라 ``DeadLock``이 걸린다.
            2.  문제가 언제 발생할 지 모른다.(간헐적 발생)
        2.  방지하기 위한 방법
            1.  ``Lock``을 잡게 잡거나
                1.  한 쪽 포크만 들고 바로 내려놓는다.
            2.  ``Lock``을 크게 잡는다
                1.  ``globalLock``
                2.  대기표를 만들고 순서대로 밥을 먹고 반납
                3.  ``컨베이어 벨트`` 방식(``생산자-소비자 패턴(producer-comsumer pattern)``)
                    1.  go의 ``channel``
                        1.  일종의 ``queue(컨베이어 벨트)`` 제공하는 것
                            1.  Thread Safe
                            2.  Fixed Size
                                1.  작업량(queue)를 지정
42. Channel
    1.  멀티 스레드를 위해 go에서 제공하는 ``type``
        1.  Fixed Size & Thread Safe queue
    2.  사용방법
        1.  선언
            1.  ``var a chan [TYPE]``
        2.  초기화
            1.  ``make(chan TYPE)``
                1.  0개 짜리 채널
                    1.  넣어주면 빼줘야 된다.
                    2.  안그러면 끝이 안난다.
        3.  어떤 타입이든지 넣을 수 있다.
        4.  ``push``와 ``pop`` 제공
            1.  `->`, `<-`
            2.  ``c := make(chan int, 1)``
            3.  push
                1.  ``c <- 10``
            4.  pop
                1.  ``v := <- c``
            5.  넣어주면 빼줘야 함
    3.  golang은 멀티스레드를 위해 다음을 제공
        1.  go thread
        2.  channel
        3.  select
    4.  멀티스레드를 왜 사용해야 하는가?
        1.  머신의 성능을 최대한 이용하기 위해서
        2.  무어의 법칙
        3.  현대는 가상화를 통해서도 멀티스레드가 가능하지만 상황에 따라 맞게 쓸 필요가 있다.
            1.  멀티프로세스로 갈지, 멀티스레드로 갈지
43. Select
    1.  여러개의 채널을 동시에 기다리게 해주는 것
    2.  사용법
        1.  switch case와 비슷한 구문
        2.  ``select{case val := <- c:>}``
    3.  Time package(코드참고)
        1.  tick
            1.  주기적으로 알려주는 channel 제공
        2.  after
            1.  특정시간 이후에 한번만 알려주는 channel 제공
44. OOP
    1.  **천천히 가는 것을 두려워 하지 말고, 가다 멈추는 것을 두려워하라**
    2. Object Oriented Programing(객체 지향 프로그래밍)
    3. OOP는 방법, 언어, 절대법칙, 기술, Mandatory가 아니고 ``개념``이다.
    4. 기존의 문제를 해결하기 위한 개념 및 방법이고 이 또한 문제가 생긴다.
       1. 기존 방법
          1. 절차적 프로그래밍(Procedure)
       2. 문제
          1. 수정이 필요할 때 스파게티 코드가 된다.(산탄총 수정) ``코드참조``
       3. 절차적 프로그래밍
          1. 순서, 절차
       4. OOP
          1. 객체의 상태와 ``기능``
          2. 각 객체 간의 ``관계``
    5. 추상적인 개념이다. 그리고 그저 기술이고 좋은 코딩을 위한 방법론이다.
45. OOP2, Object란
    1.  Object
        1.  상태
            1.  코딩이라는 것은 어떻게 상태를 바꿀지를 기술하는 것
            2.  variable, structure
        2.  기능
            1.  function
46. OOP3, Interface
    1.  Interface
        1.  객체간 상호관계 정의
        2.  decoupling이 가능
            1.  손쉽게 확장이 가능
    2.  객체
        1.  상태
        2.  기능
            1.  외부기능
                1.  Interface(외부와의 관계)
                    1.  기능만을 따로 정의
            2.  내부기능
    3.  코드참고
47. Interface2
    1.  절차적 프로그래밍
        1.  변경이 취약
    2.  OOP(Interface)
        1.  확장성이 좋다.
    3.  interface도 ``type``다.
    4.  type ``Name`` interface{``input`` ``output``}
    5.  GoLang의 특징
        1.  DuckTyping
            1.  C#, JAVA, C++과 다른 점임
                1.  class A implement interfaceA를 선언해야함
                    1.  GoLang은 행동만 interface에 구현하면 됨
            2.  오리처럼 소리내고 걷고 헤엄치면 오리다.
48. OOD의 SOLID
    1.  OOD
        1.  Object Oriented Design
        2.  Object 중심의 설계(아키텍처)
    2.  SOLID(OOD의 5가지 설계 원칙)
        1.  **Single Responsibility Principle**
            1.  단일책임원칙
                1.  하나의 객체는 하나의 책임을 가져야 한다.
                2.  Ex)
                    1.  예금잔고 객체
                        1.  입금, 출금으로 책임을 나눌 것인지
                        2.  입출금으로 할 것인지
        2.  **Open Closed Principle**
            1.  확장에는 열려있고, 변경에는 닫혀있어야 한다.
            2.  1번과 2번만 잘 지켜도 좋은 프로그래밍이다.
        3.  Liskov Subtitution Principle
            1.  리스코프 치환 이론
            2.  Base Type의 기존 함수 또는 동작을 바꾸지 말아라.(상속에서 가끔 문제가 생김)
            3.  golang에서는 상속이 없다.
                1.  그래서 golang은 oop가 아니다?
                    1.  oop에 상속이 있어야 한다는 내용은 없다.
        4.  Interface Segregation Principle
            1.  인터페이스 분리 원칙
            2.  여러개의 관계를 모아놓은 인터페이스보다 관계 하나씩 정의하는 것이 더 좋다.
                1.  Ex) 게임
                    1.  케릭터의 동작을 모은 것보다 각각 분리해놓은 것이 낫다.(의존성이 낮아짐)
        5.  Dependency Inversion Priciple
            1.  관계는 인터페이스에 의존하는 것이 객체에 의존하는 것보다 좋다.
    3.  의존성을 낮추고 응집성을 높이기 위함
49. Beyond OOP
    1.  OOP는 잘 만들기 어렵고 새로운 프로그래머가 파악하는데 시간이 오래 걸린다.
    2.  현대에 와서 생긴 OOP의 문제점
        1.  실리콘 밸리
            1.  Tech Debt
                1.  Make fast(빨리 만들고)
                2.  Break things(빨리 없애자)에서 Fast Break Things로 ...가는 움직임이 되고 Stateless가 나오게 되었다.
                3.  에 적합하지 않다
    3.  절차적 프로그래밍(상태, 기능 분리) -> OOP(상태, 기능 혼재) -> Stateless
    4.  Stateless(상태를 없애버리고 기능만 만들자, 상태는 외부에서 만들어서 가져오자, 레고조립)
        1.  Micro Service(웹)
        2.  Serverless(웹)
        3.  Functional(language)
            1.  erlang
            2.  lisp
            3.  scala
            4.  F#
            5.  elixir
        4.  ECS(게임)
            1.  Entity Component System
        5.  MVC(UI)
            1.  Model
                1.  data
            2.  View
            3.  Controller
                1.  기능
50. 마지막 강좌
    1.  컴퓨터 공학
        1.  지식
            1.  습득(공부)
        2.  기술
            1.  숙달(연습)
    2.  지속적으로 공부해야 할 것
        1.  컴퓨터원리 -> 하드웨어 -> CPU설계
        2.  프로그래밍 언어와 문법
        3.  자료구조 & 알고리즘
        4.  Thread & 고급기능
        5.  OOP -> 설계 -> 아키텍처
    3.  만들고 싶은 것이 있어야 한다.
        1.  Make Anything!!
            1.  자료조사(break down)